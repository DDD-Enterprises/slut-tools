---- Filthiness Mode: Load/Set Config ----

if [[ -z "$MODE" && -f "$CONFIG_FILE" ]]; then
MODE=$(cat "$CONFIG_FILE")
fi
---- Subcommand Detection ----

Support: gb docs, gb all, gb gangbang, gb slutify, gb pileup, gb fml <pattern>

if [[ "$1" == "docs" ]]; then
EXT_FILTER="md"
EXTRA_EXTS=("txt" "doc" "docx" "rtf")
shift
elif [[ "$1" == "all" || "$1" == "gangbang" || "$1" == "slutify" || "$1" == "pileup" ]]; then
EXT_FILTER="*"
shift
elif [[ "$1" == "fml" ]]; then
FML_PATTERN="$2"
shift 2
fi
---- Interactive Filth Mode Selection on first run ----

if [[ -z "$MODE" ]]; then
echo ""
echo "Choose your filth level:"
echo " 1) Tease (PG, flirty, safe for work)"
echo " 2) Slut (default: filthy, hilarious, ROFL)"
echo " 3) Freak (NSFW, explicit, full send)"
read -p "Pick a number [2]: " FILTH_CHOICE
case "$FILTH_CHOICE" in
1) MODE="tease" ;;
3) MODE="freak" ;;
""|2|*) MODE="slut" ;;
esac
mkdir -p "$CONFIG_DIR"
echo "$MODE" > "$CONFIG_FILE"
echo ""
fi
---- Set Messaging ----

if [[ "$MODE" == "tease" ]]; then
WELCOME="ðŸ’« Welcome! Merging your files with a wink and a smile."
LICK="âœ¨ Adding file:"
STUFF="ðŸ”— Linking content into the output..."
CLIMAX="ðŸŽ‰ All done! Your files are together, neat and tidy."
NOBODY="No files matched. Nothing to merge. Go make a mess and come back."
elif [[ "$MODE" == "freak" ]]; then
WELCOME="ðŸ’¦ Welcome to the gangbang, cumslut. Ready to get absolutely wrecked?"
LICK="ðŸ‘… Gagging on:"
STUFF="ðŸ† Fisting it into the output, screaming."
CLIMAX="ðŸ’¦ Holy shit. Youâ€™re fucking destroyed. Outputâ€™s dripping, you degenerate."
NOBODY="ðŸš« Nobody showed up to the gangbang? Blue balls. Try again, freak."
else
WELCOME="ðŸ† Starting the gangbangâ€”merge and stuff those files!"
LICK="ðŸ‘… Licking:"
STUFF="ðŸ‘ Stuffing it deep..."
CLIMAX="ðŸ’¦ Finished! Your output is absolutely soaked."
NOBODY="No files to gangbang. Lame. Throw a better party."
fi
---- Flag Parsing (continue) ----

while [[ $# -gt 0 ]]; do
case "$1" in
-o|--output) OUTPUT_FILE="$2"; shift 2 ;;
--output=) OUTPUT_FILE="${1#=}"; shift ;;
-d|--dir) TARGET_DIR="$2"; shift 2 ;;
--dir=) TARGET_DIR="${1#=}"; shift ;;
-f|--filter) FILENAME_FILTER="$2"; shift 2 ;;
--filter=) FILENAME_FILTER="${1#=}"; shift ;;
-t|--type) EXT_FILTER="$2"; shift 2 ;;
--type=) EXT_FILTER="${1#=}"; shift ;;
-n|--name) SHOW_FILENAMES=true; shift ;;
-r|--readme) INCLUDE_README=true; shift ;;
-l|--log) LOG_FILE="$2"; shift 2 ;;
--log=) LOG_FILE="${1#=}"; shift ;;
-D|--deep) DEEP_MODE=true; shift ;;
--no-deep) DEEP_MODE=false; shift ;;
-m|--mode) MODE="$2"; shift 2 ;;
--mode=) MODE="${1#=}"; shift ;;
mode)
echo ""
echo "Select your filth level:"
echo " 1) Tease"
echo " 2) Slut"
echo " 3) Freak"
read -p "Pick a number [2]: " FILTH_CHOICE
case "$FILTH_CHOICE" in
1) MODE="tease" ;;
3) MODE="freak" ;;
""|2|*) MODE="slut" ;;
esac
mkdir -p "$CONFIG_DIR"
echo "$MODE" > "$CONFIG_FILE"
echo "Filth mode set to '$MODE' and saved as your default."
exit 0
;;
-h|--help)
show_usage
;;
*) break ;;
esac
done

---- Logging ----

[[ -n "$LOG_FILE" ]] && exec 3>"$LOG_FILE" || exec 3>/dev/null
---- Deep/Recursive Mode ----

if [[ "$DEEP_MODE" = true ]]; then
FIND_OPTS="-type f"
SEARCH_DESC="DEEP MODE: Merging files recursively ðŸ”¥"
else
FIND_OPTS="-maxdepth 1 -type f"
SEARCH_DESC="Just the tip: Only top-level files ðŸ˜‡"
fi
echo -e "${CYAN_B}$SEARCH_DESC${NC}" >&2
---- Merge Files ----

echo -e "$WELCOME"
file_list=()
-- Collect files for docs mode (multi extension)

if [[ "$1" == "docs" ]]; then
for ext in "md" "txt" "doc" "docx" "rtf"; do
while IFS= read -r -d '' file; do
base=$(basename "$file")
[[ "$base" == .* || "$base" == "$OUTPUT_FILE" ]] && continue
if [[ $INCLUDE_README == false && "$base" == README* ]]; then continue; fi
if [[ -n "$FILENAME_FILTER" && "$base" != "$FILENAME_FILTER"* ]]; then continue; fi
file_list+=("$file")
done < <(find "$TARGET_DIR" $FIND_OPTS -name "*.$ext" -print0)
done
-- Collect files for fuzzy/wildcard fml mode

elif [[ "$FML_PATTERN" != "" ]]; then
while IFS= read -r -d '' file; do
base=$(basename "$file")
[[ "$base" == .* || "$base" == "$OUTPUT_FILE" ]] && continue
if [[ $INCLUDE_README == false && "$base" == README* ]]; then continue; fi
if [[ -n "$FILENAME_FILTER" && "$base" != "$FILENAME_FILTER"* ]]; then continue; fi
file_list+=("$file")
done < <(find "$TARGET_DIR" $FIND_OPTS -name "$FML_PATTERN" -print0)
-- Collect files for all/standard mode

else
if [[ "$EXT_FILTER" == "" ]]; then
while IFS= read -r -d '' file; do
base=$(basename "$file")
[[ "$base" == . || "$base" == "$OUTPUT_FILE" ]] && continue
if [[ $INCLUDE_README == false && "$base" == README* ]]; then continue; fi
if [[ -n "$FILENAME_FILTER" && "$base" != "$FILENAME_FILTER"* ]]; then continue; fi
file_list+=("$file")
done < <(find "$TARGET_DIR" $FIND_OPTS -print0)
else
while IFS= read -r -d '' file; do
base=$(basename "$file")
[[ "$base" == .* || "$base" == "$OUTPUT_FILE" ]] && continue
if [[ $INCLUDE_README == false && "$base" == README* ]]; then continue; fi
if [[ -n "$FILENAME_FILTER" && "$base" != "$FILENAME_FILTER"* ]]; then continue; fi
file_list+=("$file")
done < <(find "$TARGET_DIR" $FIND_OPTS -name "*.$EXT_FILTER" -print0)
fi
fi
if [[ ${#file_list[@]} -eq 0 ]]; then
echo -e "$NOBODY"
exit 1
fi

"$OUTPUT_FILE"
TOTAL_SIZE=0
for file in "${file_list[@]}"; do
base=$(basename "$file")
FILE_SIZE=$(stat -c%s "$file" 2>/dev/null || wc -c < "$file")
TOTAL_SIZE=$((TOTAL_SIZE + FILE_SIZE))
echo -e "${MAGENTA}$LICK ${CYAN}$base${NC} ${WHITE}[$FILE_SIZE bytes]${NC}" >&2
echo -e "${CYAN_B}$STUFF${NC}" >&2
echo "[GANGBANG] $base [$FILE_SIZE bytes]" >&3

[[ $SHOW_FILENAMES == true ]] && echo -e "\n**$base**" >> "$OUTPUT_FILE"
echo '```' >> "$OUTPUT_FILE"
cat "$file" >> "$OUTPUT_FILE"
echo -e '\n```' >> "$OUTPUT_FILE"
done

FINAL_SIZE=$(stat -c%s "$OUTPUT_FILE" 2>/dev/null || wc -c < "$OUTPUT_FILE")
echo -e "${CYAN_B}$CLIMAX${NC} ${WHITE}${OUTPUT_FILE}${NC} ${MAGENTA}[$FINAL_SIZE bytes]${NC}" >&2
echo "[GANGBANG] FINISHED. Wrote $FINAL_SIZE bytes." >&3
exit 0
