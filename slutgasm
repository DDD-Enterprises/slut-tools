#!/usr/bin/env zsh

set -eu

# 💋 slutgasm — Merge That Moans™ (DEEP MODE default, now with Undo™)

# ---- Color Theme ----

THEME="neon"

if [[ "$THEME" == "neon" ]]; then
  CYAN=$'\033[38;5;51m'
  MAGENTA=$'\033[38;5;213m'
  GREEN=$'\033[38;5;48m'
  YELLOW=$'\033[38;5;226m'
  BLUE=$'\033[38;5;69m'
  WHITE=$'\033[97m'
  BLACK=$'\033[30m'
  CYAN_B=$'\033[1;36m'
  MAGENTA_B=$'\033[1;95m'
  GREEN_B=$'\033[1;92m'
  RESET=$'\033[0m'
else
  CYAN=""; MAGENTA=""; GREEN=""; YELLOW=""; BLUE=""; WHITE=""; BLACK=""
  CYAN_B=""; MAGENTA_B=""; GREEN_B=""; RESET=""
fi

color() {
  local name="$1"
  eval "printf -- '%s' \"\$$name\""
}
reset_color() { printf '%s' "$RESET"; }

# ---- Defaults ----
OUTPUT_FILE="slutgasm_output.md"
SHOW_FILENAMES=false
INCLUDE_README=false
FILENAME_FILTER=""
EXT_FILTER="md"
TARGET_DIR="."
LOG_FILE=""
DEEP_MODE=true
UNDO_MODE=false
CLEAN_BACKUPS=false

# ---- Usage ----
usage() {
  cat <<EOF
$(color MAGENTA_B)💋 SLUTGASM$(reset_color) — $(color CYAN_B)File Merge That Moans™$(reset_color)

$(color CYAN)Merges every .md (or .txt) in sight, recursively by default (Deep Mode!).
Stuff 'em together, get code-fenced, and let your output drip.
Command-line filth, now with extra penetration, UNDO, and backup cleaning.$(reset_color)

$(color WHITE)USAGE:$(reset_color)
  slutgasm [flags]

$(color WHITE)FLAGS:$(reset_color)
  -o, --output <file>      Output file (default: slutgasm_output.md)
  -d, --dir <dir>          Directory to scan (default: .)
  -f, --filter <prefix>    Filename prefix filter (e.g., 'brat_', 'whore_')
  -t, --type <ext>         File extension (default: md)
  -n, --name               Print filename before each block
  -r, --readme             Include README files
  -l, --log <file>         Log session to file
  -T, --theme <t>          Theme: neon, none (default: neon)
  -D, --deep               Deep Mode (recursive, default ON)
      --no-deep            Shallow Mode (top-level files only)
      --undo               Restore the last merged output file from backup
      --clean-backups      Delete all .bak files in the output directory
  -h, --help               Show this help and exit

$(color MAGENTA)EXAMPLES:$(reset_color)
  slutgasm -f slut_ -n -o full_load.md
  slutgasm --type=txt -r > wet_transcript.txt
  slutgasm --dir=posts/ --filter=dom_ -n
  slutgasm --no-deep         # Just the tip, no penetration
  slutgasm --undo -o full_load.md
  slutgasm --clean-backups

EOF
  exit 0
}

fatal() {
  echo -e "$(color MAGENTA_B)[slutgasm: ERROR]$(reset_color) $*" >&2
  exit 1
}

# ---- Prevent merging with no arguments ----
if [[ "$#" -eq 0 ]]; then
  usage
fi

# ---- Argument Parsing ----
zparseopts -D -E -A opts \
  o:=o -output:=o \
  d:=d -dir:=d \
  f:=f -filter:=f \
  t:=t -type:=t \
  n=n -name=n \
  r=r -readme=r \
  l:=l -log:=l \
  T:=T -theme:=T \
  D=D -deep=D \
  h=h -help=h \
  -no-deep=no_deep \
  -undo=undo \
  -clean-backups=clean_backups

if (( ${#h} )); then usage; fi
if (( ${#o} )); then OUTPUT_FILE="${o[-1]}"; fi
if (( ${#d} )); then TARGET_DIR="${d[-1]}"; fi
if (( ${#f} )); then FILENAME_FILTER="${f[-1]}"; fi
if (( ${#t} )); then EXT_FILTER="${t[-1]}"; fi
if (( ${#n} )); then SHOW_FILENAMES=true; fi
if (( ${#r} )); then INCLUDE_README=true; fi
if (( ${#l} )); then LOG_FILE="${l[-1]}"; fi
if (( ${#T} )); then THEME="${T[-1]}"; fi
if (( ${#D} )); then DEEP_MODE=true; fi
if (( ${#no_deep} )); then DEEP_MODE=false; fi
if (( ${#undo} )); then UNDO_MODE=true; fi
if (( ${#clean_backups} )); then CLEAN_BACKUPS=true; fi

[[ ! -d "$TARGET_DIR" ]] && fatal "Directory not found: $TARGET_DIR"
[[ -z "$EXT_FILTER" ]] && fatal "File extension cannot be empty"

# ---- Clean backups mode ----
if [[ "$CLEAN_BACKUPS" == true ]]; then
  deleted=0
  for bak in "$TARGET_DIR"/*.bak(N); do
    if [[ -f "$bak" ]]; then
      rm "$bak"
      echo "Deleted backup: $bak"
      ((deleted++))
    fi
  done
  if (( deleted == 0 )); then
    echo "No backup files found to delete in $TARGET_DIR."
  else
    echo "Deleted $deleted backup file(s) from $TARGET_DIR."
  fi
  exit 0
fi

# ---- Undo mode ----
if [[ "$UNDO_MODE" == true ]]; then
  BACKUP_FILE="${OUTPUT_FILE}.bak"
  if [[ -f "$BACKUP_FILE" ]]; then
    mv "$BACKUP_FILE" "$OUTPUT_FILE"
    echo "Undo complete: restored $OUTPUT_FILE from backup."
    exit 0
  else
    echo "Nothing to undo: no backup file found for $OUTPUT_FILE."
    exit 1
  fi
fi

# ---- Prevent accidental overwrite of source as output ----
[[ -e "$OUTPUT_FILE" ]] && [[ "$(realpath "$OUTPUT_FILE")" == "$(realpath "$TARGET_DIR/$OUTPUT_FILE" 2>/dev/null)" ]] && fatal "Output file would overwrite source files!"

# ---- Logging ----
if [[ -n "$LOG_FILE" ]]; then
  exec 3>"$LOG_FILE"
else
  exec 3>/dev/null
fi

# ---- Deep/Recursive Mode Selection ----
if [[ "$DEEP_MODE" == true ]]; then
  FIND_OPTS=()
  SEARCH_DESC="DEEP MODE: Merging files recursively 🔥"
else
  FIND_OPTS=(-maxdepth 1)
  SEARCH_DESC="Just the tip: Only top-level files 😇"
fi
echo -e "$(color CYAN_B)$SEARCH_DESC$(reset_color)" >&2

# ---- File Collection ----
file_list=()
while IFS= read -r -d '' file; do
  base=$(basename "$file")
  [[ "$base" == .* ]] && continue
  [[ "$base" == "$OUTPUT_FILE" ]] && continue
  [[ $INCLUDE_README == false && "$base" == README* ]] && continue
  [[ -n "$FILENAME_FILTER" && "${base}" != "$FILENAME_FILTER"* ]] && continue
  file_list+=("$file")
done < <(find "$TARGET_DIR" "${FIND_OPTS[@]}" -type f -name "*.$EXT_FILTER" -print0 | LC_ALL=C sort -z)

if [[ ${#file_list[@]} -eq 0 ]]; then
  echo -e "$(color YELLOW)No matching files found in $TARGET_DIR with extension .$EXT_FILTER$(reset_color)" >&2
  exit 2
fi

# ---- Backup previous output (for undo) ----
if [[ -f "$OUTPUT_FILE" ]]; then
  cp "$OUTPUT_FILE" "${OUTPUT_FILE}.bak"
fi

# ---- Merge Loop ----
: > "$OUTPUT_FILE"
TOTAL_SIZE=0
for file in "${file_list[@]}"; do
  base=$(basename "$file")
  FILE_SIZE=$(stat -f%z "$file" 2>/dev/null || wc -c < "$file")
  TOTAL_SIZE=$((TOTAL_SIZE + FILE_SIZE))
  echo -e "$(color MAGENTA)👅 Licking: $(color CYAN)$base$(reset_color) $(color WHITE)[${FILE_SIZE} bytes]$(reset_color)" >&2
  echo -e "$(color CYAN_B)🍆 Stuffing it deep into ${OUTPUT_FILE}...$(reset_color)" >&2
  echo "[SLUTGASM] $base [${FILE_SIZE} bytes]" >&3

  [[ $SHOW_FILENAMES == true ]] && echo -e "\n**$base**" >> "$OUTPUT_FILE"
  echo '```' >> "$OUTPUT_FILE"
  cat "$file" >> "$OUTPUT_FILE"
  echo -e '\n```' >> "$OUTPUT_FILE"
done

FINAL_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || wc -c < "$OUTPUT_FILE")
echo -e "$(color CYAN_B)💦 Finished. Your output is soaked: $(color WHITE)${OUTPUT_FILE}$(reset_color) $(color MAGENTA)[${FINAL_SIZE} bytes]$(reset_color)" >&2
echo "[SLUTGASM] FINISHED. Wrote $FINAL_SIZE bytes." >&3

exit 0
